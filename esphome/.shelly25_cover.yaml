<<: !include .defaults.yaml

# this setup uses momentary switches!!!
#
# sensor A must be connected to the upwards switch
# sensor B must be connected to the downwards switch
# actor direction can be changed by setting switch_a and switch_b to "up"/"down"

esphome:
  name: ${name}
  platform: ESP8266
  board: esp01_1m
  on_shutdown:
    then:
      # store the current cover position
      - globals.set:
          id: cover_position
          value: id(${name}_cover).position
  on_boot:
    then:
      # restore the cover position
      - lambda: id(${name}_cover).publish_state(id(cover_position));
      # restore upper endstop status based on cover position
      - if:
          condition:
            lambda: 'return id(cover_position) == 100;'
          then:
            - binary_sensor.template.publish:
                id: "${name}_endstop_up"
                state: ON
          else:
            - binary_sensor.template.publish:
                id: "${name}_endstop_up"
                state: OFF
      # restore lower endstop status based on cover position
      - if:
          condition:
            lambda: 'return id(cover_position) == 0;'
          then:
            - binary_sensor.template.publish:
                id: "${name}_endstop_down"
                state: ON
          else:
            - binary_sensor.template.publish:
                id: "${name}_endstop_down"
                state: OFF

i2c:
  sda: GPIO12
  scl: GPIO14
  scan: False

globals:
  # used to store the state of the cover while rebooting the device
  - id: cover_position
    type: int
    restore_value: yes

sensor:
  # uptime sensor
  - platform: uptime
    name: "${name} uptime"
    unit_of_measurement: days
    filters:
      - lambda: return x / 60 / 60 / 24;
  # wifi signal sensor
  - platform: wifi_signal
    name: "${name} wifi signal"
    filters:
      - or:
        - heartbeat: 1h
        - delta: 3

  # power measurement
  - platform: ade7953
    address: 0x38
    update_interval: 1s
    voltage:
      name: "${name} voltage"
      filters:
        - throttle: ${update_throttle}
    current_a:
      name: "${name} current A"
      filters:
        - lambda: if (x < 0.1) return 0; else return (x);
        - or:
          - throttle: ${update_throttle}
          - delta: 0.03
    current_b:
      name: "${name} current B"
      filters:
        - lambda: if (x < 0.1) return 0; else return (x);
        - or:
          - throttle: ${update_throttle}
          - delta: 0.03
    active_power_a:
      id: "${name}_power_usage_a"
      name: "${name} power A"
      unit_of_measurement: W
      icon: mdi:flash-circle
      accuracy_decimals: 0
      filters:
        - lambda: if (x < 1) return 0; else return (x);
        - or:
          - throttle: ${update_throttle}
          - delta: 1
      on_value:
        then:
          # consumption is higher than the moving threshold
          # mark motor active and not in slowdown
          - if:
              condition:
                lambda: 'return id(${name}_power_usage_a).state > ${cover_moving};'
              then:
                - logger.log:
                    format: "Cover is moving ${switch_a}"
                    level: INFO
                - binary_sensor.template.publish:
                    id: "${name}_powered"
                    state: ON
                - binary_sensor.template.publish:
                    id: "${name}_slowdown_${switch_a}"
                    state: OFF
          # consumption is higher than the stopping threshold but less than the moving threshold
          # mark motor active and slowing down
          - if:
              condition:
                - lambda: 'return id(${name}_power_usage_a).state > ${cover_stopping};'
                - lambda: 'return id(${name}_power_usage_a).state < ${cover_moving};'
              then:
                - logger.log:
                    format: "Cover is close to the ${switch_a}wards endposition and slowing down"
                    level: INFO
                - binary_sensor.template.publish:
                    id: "${name}_powered"
                    state: ON
                - binary_sensor.template.publish:
                    id: "${name}_slowdown_${switch_a}"
                    state: ON
          # consumption is less than the full stop threshold and motor is marked active and slowing down
          # mark motor fully stopped
          - if:
              condition:
                - lambda: 'return id(${name}_power_usage_a).state < ${cover_stopped};'
                - binary_sensor.is_on: "${name}_powered"
                - binary_sensor.is_on: "${name}_slowdown_${switch_a}"
              then:
                - logger.log:
                    format: "Cover has reached the ${switch_a}wards endposition and stopped"
                    level: INFO
                - binary_sensor.template.publish:
                    id: "${name}_endstop_${switch_a}"
                    state: ON
                - binary_sensor.template.publish:
                    id: "${name}_powered"
                    state: OFF
                - binary_sensor.template.publish:
                    id: "${name}_slowdown_${switch_a}"
                    state: OFF
          # consumption is less than the full stop threshold and motor is marked active but not yet slowing down
          # mark motor fully stopped
          - if:
              condition:
                - lambda: 'return id(${name}_power_usage_a).state < ${cover_stopped};'
                - binary_sensor.is_on: "${name}_powered"
              then:
                - logger.log:
                    format: "Cover has been stopped on the way ${switch_a}"
                    level: INFO
                - binary_sensor.template.publish:
                    id: "${name}_powered"
                    state: OFF
    active_power_b:
      id: "${name}_power_usage_b"
      name: "${name} power B"
      unit_of_measurement: W
      icon: mdi:flash-circle
      accuracy_decimals: 0
      filters:
        - multiply: -1
        - lambda: if (x < 1) return 0; else return (x);
        - or:
          - throttle: ${update_throttle}
          - delta: 1
      on_value:
        then:
          # consumption is higher than the moving threshold
          # mark motor active and not in slowdown
          - if:
              condition:
                lambda: 'return id(${name}_power_usage_b).state > ${cover_moving};'
              then:
                - logger.log:
                    format: "Cover is moving ${switch_b}"
                    level: INFO
                - binary_sensor.template.publish:
                    id: "${name}_powered"
                    state: ON
                - binary_sensor.template.publish:
                    id: "${name}_slowdown_${switch_b}"
                    state: OFF
          # consumption is higher than the stopping threshold but less than the moving threshold
          # mark motor active and slowing down
          - if:
              condition:
                - lambda: 'return id(${name}_power_usage_b).state > ${cover_stopping};'
                - lambda: 'return id(${name}_power_usage_b).state < ${cover_moving};'
              then:
                - logger.log:
                    format: "Cover is close to the ${switch_b}wards endposition and slowing down"
                    level: INFO
                - binary_sensor.template.publish:
                    id: "${name}_powered"
                    state: ON
                - binary_sensor.template.publish:
                    id: "${name}_slowdown_${switch_b}"
                    state: ON
          # consumption is less than the full stop threshold and motor is marked active and slowing down
          # mark motor fully stopped
          - if:
              condition:
                - lambda: 'return id(${name}_power_usage_b).state < ${cover_stopped};'
                - binary_sensor.is_on: "${name}_powered"
                - binary_sensor.is_on: "${name}_slowdown_${switch_b}"
              then:
                - logger.log:
                    format: "Cover has reached the ${switch_b}wards endposition and stopped"
                    level: INFO
                - binary_sensor.template.publish:
                    id: "${name}_endstop_${switch_b}"
                    state: ON
                - binary_sensor.template.publish:
                    id: "${name}_powered"
                    state: OFF
                - binary_sensor.template.publish:
                    id: "${name}_slowdown_${switch_b}"
                    state: OFF
          # consumption is less than the full stop threshold and motor is marked active but not yet slowing down
          # mark motor fully stopped
          - if:
              condition:
                - lambda: 'return id(${name}_power_usage_b).state < ${cover_stopped};'
                - binary_sensor.is_on: "${name}_powered"
              then:
                - logger.log:
                    format: "Cover has been stopped on the way ${switch_b}"
                    level: INFO
                - binary_sensor.template.publish:
                    id: "${name}_powered"
                    state: OFF

  # device temperature
  - platform: ntc
    sensor: "${name}_resistance_reading"
    id: "${name}_temperature"
    name: "${name} temperature"
    calibration:
      b_constant: 3350
      reference_resistance: 10kOhm
      reference_temperature: 298.15K
  - platform: resistance
    id: "${name}_resistance_reading"
    sensor: "${name}_analog_reading"
    configuration: DOWNSTREAM
    resistor: 32kOhm
  - platform: adc
    id: "${name}_analog_reading"
    pin: A0

binary_sensor:
  # device status sensor
  - platform: status
    name: "${name}_status"
  # binary sensor for the button A press
  - platform: gpio
    name: "${name} sensor A"
    pin:
      number: GPIO13
      inverted: false
    on_press:
      # if the motor is moving, every press should just stop it
      - if:
          condition:
            binary_sensor.is_on: "${name}_powered"
          then:
            - switch.turn_off: "${name}_cover_up"
            - switch.turn_off: "${name}_cover_down"
      # if the motor is not moving and we didn't reach the end stop yet then start it
      - if:
          condition:
            - binary_sensor.is_off: "${name}_powered"
            - binary_sensor.is_off: "${name}_endstop_up"
          then:
            - cover.open: "${name}_cover"
  # binary sensor for the button B press
  - platform: gpio
    name: "${name} sensor B"
    pin:
      number: GPIO5
      inverted: false
    on_press:
      # if the motor is moving, every press should just stop it
      - if:
          condition:
            binary_sensor.is_on: "${name}_powered"
          then:
            - switch.turn_off: "${name}_cover_up"
            - switch.turn_off: "${name}_cover_down"
      # if the motor is not moving and we didn't reach the end stop yet then start it
      - if:
          condition:
            not:
              binary_sensor.is_on: "${name}_endstop_down"
          then:
            - cover.close: "${name}_cover"
  # endstop sensors
  - platform: template
    id: "${name}_endstop_up"
    name: "${name} up endstop"
  - platform: template
    id: "${name}_slowdown_up"
    name: "${name} up slowdown"
  - platform: template
    id: "${name}_endstop_down"
    name: "${name} down endstop"
  - platform: template
    id: "${name}_slowdown_down"
    name: "${name} down slowdown"
  - platform: template
    id: "${name}_powered"
    name: "${name} is powered"

switch:
  - platform: restart
    name: ${name} Restart
  # actual switch powering the motor, direction is defined by setting switch_a to "up" or "down"
  - platform: gpio
    id: "${name}_cover_${switch_a}"
    name: "${name} cover ${switch_a}"
    pin:
      number: GPIO15
    # prevent both switches from being turned on at the same time
    interlock: &interlock ["${name}_cover_up", "${name}_cover_down"]
    interlock_wait_time: 500ms
    # when starting to move, turn both end stop markers off
    on_turn_on:
      - binary_sensor.template.publish:
          id: "${name}_endstop_up"
          state: OFF
      - binary_sensor.template.publish:
          id: "${name}_endstop_down"
          state: OFF
  # actual switch powering the motor, direction is defined by setting switch_b to "up" or "down"
  - platform: gpio
    id: "${name}_cover_${switch_b}"
    name: "${name} cover ${switch_b}"
    pin:
      number: GPIO4
    # prevent both switches from being turned on at the same time
    interlock: *interlock
    interlock_wait_time: 500ms
    # when starting to move, turn both end stop markers off
    on_turn_on:
      - binary_sensor.template.publish:
          id: "${name}_endstop_up"
          state: OFF
      - binary_sensor.template.publish:
          id: "${name}_endstop_down"
          state: OFF

cover:
  - platform: endstop
    name: "${name} cover"
    id: "${name}_cover"
    max_duration: ${max_duration}

    open_action:
      - switch.turn_on: "${name}_cover_up"
    open_duration: ${open_duration}
    open_endstop: "${name}_endstop_up"

    close_action:
      - switch.turn_on: "${name}_cover_down"
    close_duration: ${close_duration}
    close_endstop: "${name}_endstop_down"

    stop_action:
      - switch.turn_off: "${name}_cover_up"
      - switch.turn_off: "${name}_cover_down"
